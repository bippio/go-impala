// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cli_service

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type TCLIService interface {
	// Parameters:
	//  - Req
	OpenSession(req *TOpenSessionReq) (r *TOpenSessionResp, err error)
	// Parameters:
	//  - Req
	CloseSession(req *TCloseSessionReq) (r *TCloseSessionResp, err error)
	// Parameters:
	//  - Req
	GetInfo(req *TGetInfoReq) (r *TGetInfoResp, err error)
	// Parameters:
	//  - Req
	ExecuteStatement(req *TExecuteStatementReq) (r *TExecuteStatementResp, err error)
	// Parameters:
	//  - Req
	GetTypeInfo(req *TGetTypeInfoReq) (r *TGetTypeInfoResp, err error)
	// Parameters:
	//  - Req
	GetCatalogs(req *TGetCatalogsReq) (r *TGetCatalogsResp, err error)
	// Parameters:
	//  - Req
	GetSchemas(req *TGetSchemasReq) (r *TGetSchemasResp, err error)
	// Parameters:
	//  - Req
	GetTables(req *TGetTablesReq) (r *TGetTablesResp, err error)
	// Parameters:
	//  - Req
	GetTableTypes(req *TGetTableTypesReq) (r *TGetTableTypesResp, err error)
	// Parameters:
	//  - Req
	GetColumns(req *TGetColumnsReq) (r *TGetColumnsResp, err error)
	// Parameters:
	//  - Req
	GetFunctions(req *TGetFunctionsReq) (r *TGetFunctionsResp, err error)
	// Parameters:
	//  - Req
	GetOperationStatus(req *TGetOperationStatusReq) (r *TGetOperationStatusResp, err error)
	// Parameters:
	//  - Req
	CancelOperation(req *TCancelOperationReq) (r *TCancelOperationResp, err error)
	// Parameters:
	//  - Req
	CloseOperation(req *TCloseOperationReq) (r *TCloseOperationResp, err error)
	// Parameters:
	//  - Req
	GetResultSetMetadata(req *TGetResultSetMetadataReq) (r *TGetResultSetMetadataResp, err error)
	// Parameters:
	//  - Req
	FetchResults(req *TFetchResultsReq) (r *TFetchResultsResp, err error)
}

type TCLIServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewTCLIServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *TCLIServiceClient {
	return &TCLIServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewTCLIServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *TCLIServiceClient {
	return &TCLIServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) OpenSession(req *TOpenSessionReq) (r *TOpenSessionResp, err error) {
	if err = p.sendOpenSession(req); err != nil {
		return
	}
	return p.recvOpenSession()
}

func (p *TCLIServiceClient) sendOpenSession(req *TOpenSessionReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("OpenSession", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := OpenSessionArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvOpenSession() (value *TOpenSessionResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error24 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error25 error
		error25, err = error24.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error25
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "OpenSession failed: out of sequence response")
		return
	}
	result := OpenSessionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) CloseSession(req *TCloseSessionReq) (r *TCloseSessionResp, err error) {
	if err = p.sendCloseSession(req); err != nil {
		return
	}
	return p.recvCloseSession()
}

func (p *TCLIServiceClient) sendCloseSession(req *TCloseSessionReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("CloseSession", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CloseSessionArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvCloseSession() (value *TCloseSessionResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error26 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error27 error
		error27, err = error26.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error27
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "CloseSession failed: out of sequence response")
		return
	}
	result := CloseSessionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetInfo(req *TGetInfoReq) (r *TGetInfoResp, err error) {
	if err = p.sendGetInfo(req); err != nil {
		return
	}
	return p.recvGetInfo()
}

func (p *TCLIServiceClient) sendGetInfo(req *TGetInfoReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetInfoArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetInfo() (value *TGetInfoResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetInfo failed: out of sequence response")
		return
	}
	result := GetInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) ExecuteStatement(req *TExecuteStatementReq) (r *TExecuteStatementResp, err error) {
	if err = p.sendExecuteStatement(req); err != nil {
		return
	}
	return p.recvExecuteStatement()
}

func (p *TCLIServiceClient) sendExecuteStatement(req *TExecuteStatementReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("ExecuteStatement", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExecuteStatementArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvExecuteStatement() (value *TExecuteStatementResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error30 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error31 error
		error31, err = error30.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error31
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ExecuteStatement failed: out of sequence response")
		return
	}
	result := ExecuteStatementResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetTypeInfo(req *TGetTypeInfoReq) (r *TGetTypeInfoResp, err error) {
	if err = p.sendGetTypeInfo(req); err != nil {
		return
	}
	return p.recvGetTypeInfo()
}

func (p *TCLIServiceClient) sendGetTypeInfo(req *TGetTypeInfoReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTypeInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTypeInfoArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetTypeInfo() (value *TGetTypeInfoResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTypeInfo failed: out of sequence response")
		return
	}
	result := GetTypeInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetCatalogs(req *TGetCatalogsReq) (r *TGetCatalogsResp, err error) {
	if err = p.sendGetCatalogs(req); err != nil {
		return
	}
	return p.recvGetCatalogs()
}

func (p *TCLIServiceClient) sendGetCatalogs(req *TGetCatalogsReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetCatalogs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetCatalogsArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetCatalogs() (value *TGetCatalogsResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetCatalogs failed: out of sequence response")
		return
	}
	result := GetCatalogsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetSchemas(req *TGetSchemasReq) (r *TGetSchemasResp, err error) {
	if err = p.sendGetSchemas(req); err != nil {
		return
	}
	return p.recvGetSchemas()
}

func (p *TCLIServiceClient) sendGetSchemas(req *TGetSchemasReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetSchemas", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetSchemasArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetSchemas() (value *TGetSchemasResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetSchemas failed: out of sequence response")
		return
	}
	result := GetSchemasResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetTables(req *TGetTablesReq) (r *TGetTablesResp, err error) {
	if err = p.sendGetTables(req); err != nil {
		return
	}
	return p.recvGetTables()
}

func (p *TCLIServiceClient) sendGetTables(req *TGetTablesReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTables", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTablesArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetTables() (value *TGetTablesResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTables failed: out of sequence response")
		return
	}
	result := GetTablesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetTableTypes(req *TGetTableTypesReq) (r *TGetTableTypesResp, err error) {
	if err = p.sendGetTableTypes(req); err != nil {
		return
	}
	return p.recvGetTableTypes()
}

func (p *TCLIServiceClient) sendGetTableTypes(req *TGetTableTypesReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTableTypes", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTableTypesArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetTableTypes() (value *TGetTableTypesResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTableTypes failed: out of sequence response")
		return
	}
	result := GetTableTypesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetColumns(req *TGetColumnsReq) (r *TGetColumnsResp, err error) {
	if err = p.sendGetColumns(req); err != nil {
		return
	}
	return p.recvGetColumns()
}

func (p *TCLIServiceClient) sendGetColumns(req *TGetColumnsReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetColumns", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetColumnsArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetColumns() (value *TGetColumnsResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error42 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error43 error
		error43, err = error42.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error43
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetColumns failed: out of sequence response")
		return
	}
	result := GetColumnsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetFunctions(req *TGetFunctionsReq) (r *TGetFunctionsResp, err error) {
	if err = p.sendGetFunctions(req); err != nil {
		return
	}
	return p.recvGetFunctions()
}

func (p *TCLIServiceClient) sendGetFunctions(req *TGetFunctionsReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetFunctions", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetFunctionsArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetFunctions() (value *TGetFunctionsResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetFunctions failed: out of sequence response")
		return
	}
	result := GetFunctionsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetOperationStatus(req *TGetOperationStatusReq) (r *TGetOperationStatusResp, err error) {
	if err = p.sendGetOperationStatus(req); err != nil {
		return
	}
	return p.recvGetOperationStatus()
}

func (p *TCLIServiceClient) sendGetOperationStatus(req *TGetOperationStatusReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetOperationStatus", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetOperationStatusArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetOperationStatus() (value *TGetOperationStatusResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error46 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error47 error
		error47, err = error46.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error47
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetOperationStatus failed: out of sequence response")
		return
	}
	result := GetOperationStatusResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) CancelOperation(req *TCancelOperationReq) (r *TCancelOperationResp, err error) {
	if err = p.sendCancelOperation(req); err != nil {
		return
	}
	return p.recvCancelOperation()
}

func (p *TCLIServiceClient) sendCancelOperation(req *TCancelOperationReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("CancelOperation", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CancelOperationArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvCancelOperation() (value *TCancelOperationResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error48 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error49 error
		error49, err = error48.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error49
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "CancelOperation failed: out of sequence response")
		return
	}
	result := CancelOperationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) CloseOperation(req *TCloseOperationReq) (r *TCloseOperationResp, err error) {
	if err = p.sendCloseOperation(req); err != nil {
		return
	}
	return p.recvCloseOperation()
}

func (p *TCLIServiceClient) sendCloseOperation(req *TCloseOperationReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("CloseOperation", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CloseOperationArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvCloseOperation() (value *TCloseOperationResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error50 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error51 error
		error51, err = error50.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error51
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "CloseOperation failed: out of sequence response")
		return
	}
	result := CloseOperationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) GetResultSetMetadata(req *TGetResultSetMetadataReq) (r *TGetResultSetMetadataResp, err error) {
	if err = p.sendGetResultSetMetadata(req); err != nil {
		return
	}
	return p.recvGetResultSetMetadata()
}

func (p *TCLIServiceClient) sendGetResultSetMetadata(req *TGetResultSetMetadataReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetResultSetMetadata", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetResultSetMetadataArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvGetResultSetMetadata() (value *TGetResultSetMetadataResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error52 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error53 error
		error53, err = error52.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error53
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetResultSetMetadata failed: out of sequence response")
		return
	}
	result := GetResultSetMetadataResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *TCLIServiceClient) FetchResults(req *TFetchResultsReq) (r *TFetchResultsResp, err error) {
	if err = p.sendFetchResults(req); err != nil {
		return
	}
	return p.recvFetchResults()
}

func (p *TCLIServiceClient) sendFetchResults(req *TFetchResultsReq) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("FetchResults", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FetchResultsArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TCLIServiceClient) recvFetchResults() (value *TFetchResultsResp, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error54 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error55 error
		error55, err = error54.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error55
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "FetchResults failed: out of sequence response")
		return
	}
	result := FetchResultsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

type TCLIServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      TCLIService
}

func (p *TCLIServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *TCLIServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *TCLIServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTCLIServiceProcessor(handler TCLIService) *TCLIServiceProcessor {

	self56 := &TCLIServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self56.processorMap["OpenSession"] = &tCLIServiceProcessorOpenSession{handler: handler}
	self56.processorMap["CloseSession"] = &tCLIServiceProcessorCloseSession{handler: handler}
	self56.processorMap["GetInfo"] = &tCLIServiceProcessorGetInfo{handler: handler}
	self56.processorMap["ExecuteStatement"] = &tCLIServiceProcessorExecuteStatement{handler: handler}
	self56.processorMap["GetTypeInfo"] = &tCLIServiceProcessorGetTypeInfo{handler: handler}
	self56.processorMap["GetCatalogs"] = &tCLIServiceProcessorGetCatalogs{handler: handler}
	self56.processorMap["GetSchemas"] = &tCLIServiceProcessorGetSchemas{handler: handler}
	self56.processorMap["GetTables"] = &tCLIServiceProcessorGetTables{handler: handler}
	self56.processorMap["GetTableTypes"] = &tCLIServiceProcessorGetTableTypes{handler: handler}
	self56.processorMap["GetColumns"] = &tCLIServiceProcessorGetColumns{handler: handler}
	self56.processorMap["GetFunctions"] = &tCLIServiceProcessorGetFunctions{handler: handler}
	self56.processorMap["GetOperationStatus"] = &tCLIServiceProcessorGetOperationStatus{handler: handler}
	self56.processorMap["CancelOperation"] = &tCLIServiceProcessorCancelOperation{handler: handler}
	self56.processorMap["CloseOperation"] = &tCLIServiceProcessorCloseOperation{handler: handler}
	self56.processorMap["GetResultSetMetadata"] = &tCLIServiceProcessorGetResultSetMetadata{handler: handler}
	self56.processorMap["FetchResults"] = &tCLIServiceProcessorFetchResults{handler: handler}
	return self56
}

func (p *TCLIServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x57 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x57.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x57

}

type tCLIServiceProcessorOpenSession struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorOpenSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := OpenSessionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("OpenSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := OpenSessionResult{}
	var retval *TOpenSessionResp
	var err2 error
	if retval, err2 = p.handler.OpenSession(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing OpenSession: "+err2.Error())
		oprot.WriteMessageBegin("OpenSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("OpenSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorCloseSession struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorCloseSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CloseSessionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("CloseSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CloseSessionResult{}
	var retval *TCloseSessionResp
	var err2 error
	if retval, err2 = p.handler.CloseSession(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CloseSession: "+err2.Error())
		oprot.WriteMessageBegin("CloseSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("CloseSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetInfo struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetInfoResult{}
	var retval *TGetInfoResp
	var err2 error
	if retval, err2 = p.handler.GetInfo(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetInfo: "+err2.Error())
		oprot.WriteMessageBegin("GetInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorExecuteStatement struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorExecuteStatement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExecuteStatementArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("ExecuteStatement", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExecuteStatementResult{}
	var retval *TExecuteStatementResp
	var err2 error
	if retval, err2 = p.handler.ExecuteStatement(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing ExecuteStatement: "+err2.Error())
		oprot.WriteMessageBegin("ExecuteStatement", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("ExecuteStatement", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetTypeInfo struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetTypeInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTypeInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTypeInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTypeInfoResult{}
	var retval *TGetTypeInfoResp
	var err2 error
	if retval, err2 = p.handler.GetTypeInfo(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTypeInfo: "+err2.Error())
		oprot.WriteMessageBegin("GetTypeInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTypeInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetCatalogs struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetCatalogs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetCatalogsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetCatalogs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetCatalogsResult{}
	var retval *TGetCatalogsResp
	var err2 error
	if retval, err2 = p.handler.GetCatalogs(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetCatalogs: "+err2.Error())
		oprot.WriteMessageBegin("GetCatalogs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetCatalogs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetSchemas struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetSchemas) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetSchemasArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetSchemas", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetSchemasResult{}
	var retval *TGetSchemasResp
	var err2 error
	if retval, err2 = p.handler.GetSchemas(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetSchemas: "+err2.Error())
		oprot.WriteMessageBegin("GetSchemas", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetSchemas", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetTables struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetTables) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTablesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTables", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTablesResult{}
	var retval *TGetTablesResp
	var err2 error
	if retval, err2 = p.handler.GetTables(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTables: "+err2.Error())
		oprot.WriteMessageBegin("GetTables", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTables", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetTableTypes struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetTableTypes) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableTypesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTableTypes", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableTypesResult{}
	var retval *TGetTableTypesResp
	var err2 error
	if retval, err2 = p.handler.GetTableTypes(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTableTypes: "+err2.Error())
		oprot.WriteMessageBegin("GetTableTypes", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTableTypes", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetColumns struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetColumns) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetColumnsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetColumnsResult{}
	var retval *TGetColumnsResp
	var err2 error
	if retval, err2 = p.handler.GetColumns(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetColumns: "+err2.Error())
		oprot.WriteMessageBegin("GetColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetColumns", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetFunctions struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetFunctions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetFunctionsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetFunctions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetFunctionsResult{}
	var retval *TGetFunctionsResp
	var err2 error
	if retval, err2 = p.handler.GetFunctions(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetFunctions: "+err2.Error())
		oprot.WriteMessageBegin("GetFunctions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetFunctions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetOperationStatus struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetOperationStatus) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetOperationStatusArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetOperationStatus", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetOperationStatusResult{}
	var retval *TGetOperationStatusResp
	var err2 error
	if retval, err2 = p.handler.GetOperationStatus(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetOperationStatus: "+err2.Error())
		oprot.WriteMessageBegin("GetOperationStatus", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetOperationStatus", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorCancelOperation struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorCancelOperation) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CancelOperationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("CancelOperation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CancelOperationResult{}
	var retval *TCancelOperationResp
	var err2 error
	if retval, err2 = p.handler.CancelOperation(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CancelOperation: "+err2.Error())
		oprot.WriteMessageBegin("CancelOperation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("CancelOperation", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorCloseOperation struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorCloseOperation) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CloseOperationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("CloseOperation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CloseOperationResult{}
	var retval *TCloseOperationResp
	var err2 error
	if retval, err2 = p.handler.CloseOperation(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CloseOperation: "+err2.Error())
		oprot.WriteMessageBegin("CloseOperation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("CloseOperation", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorGetResultSetMetadata struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorGetResultSetMetadata) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetResultSetMetadataArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetResultSetMetadata", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetResultSetMetadataResult{}
	var retval *TGetResultSetMetadataResp
	var err2 error
	if retval, err2 = p.handler.GetResultSetMetadata(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetResultSetMetadata: "+err2.Error())
		oprot.WriteMessageBegin("GetResultSetMetadata", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetResultSetMetadata", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tCLIServiceProcessorFetchResults struct {
	handler TCLIService
}

func (p *tCLIServiceProcessorFetchResults) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FetchResultsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("FetchResults", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FetchResultsResult{}
	var retval *TFetchResultsResp
	var err2 error
	if retval, err2 = p.handler.FetchResults(args.Req); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing FetchResults: "+err2.Error())
		oprot.WriteMessageBegin("FetchResults", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("FetchResults", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type OpenSessionArgs struct {
	Req *TOpenSessionReq `thrift:"req,1" json:"req"`
}

func NewOpenSessionArgs() *OpenSessionArgs {
	return &OpenSessionArgs{}
}

var OpenSessionArgs_Req_DEFAULT *TOpenSessionReq

func (p *OpenSessionArgs) GetReq() *TOpenSessionReq {
	if !p.IsSetReq() {
		return OpenSessionArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *OpenSessionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *OpenSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenSessionArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TOpenSessionReq{
		ClientProtocol: 0,
	}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *OpenSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("OpenSession_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *OpenSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenSessionArgs(%+v)", *p)
}

type OpenSessionResult struct {
	Success *TOpenSessionResp `thrift:"success,0" json:"success"`
}

func NewOpenSessionResult() *OpenSessionResult {
	return &OpenSessionResult{}
}

var OpenSessionResult_Success_DEFAULT *TOpenSessionResp

func (p *OpenSessionResult) GetSuccess() *TOpenSessionResp {
	if !p.IsSetSuccess() {
		return OpenSessionResult_Success_DEFAULT
	}
	return p.Success
}
func (p *OpenSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *OpenSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenSessionResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TOpenSessionResp{
		ServerProtocolVersion: 0,
	}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *OpenSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("OpenSession_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenSessionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *OpenSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenSessionResult(%+v)", *p)
}

type CloseSessionArgs struct {
	Req *TCloseSessionReq `thrift:"req,1" json:"req"`
}

func NewCloseSessionArgs() *CloseSessionArgs {
	return &CloseSessionArgs{}
}

var CloseSessionArgs_Req_DEFAULT *TCloseSessionReq

func (p *CloseSessionArgs) GetReq() *TCloseSessionReq {
	if !p.IsSetReq() {
		return CloseSessionArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *CloseSessionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CloseSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseSessionArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TCloseSessionReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *CloseSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CloseSession_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *CloseSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseSessionArgs(%+v)", *p)
}

type CloseSessionResult struct {
	Success *TCloseSessionResp `thrift:"success,0" json:"success"`
}

func NewCloseSessionResult() *CloseSessionResult {
	return &CloseSessionResult{}
}

var CloseSessionResult_Success_DEFAULT *TCloseSessionResp

func (p *CloseSessionResult) GetSuccess() *TCloseSessionResp {
	if !p.IsSetSuccess() {
		return CloseSessionResult_Success_DEFAULT
	}
	return p.Success
}
func (p *CloseSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CloseSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseSessionResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TCloseSessionResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *CloseSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CloseSession_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseSessionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CloseSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseSessionResult(%+v)", *p)
}

type GetInfoArgs struct {
	Req *TGetInfoReq `thrift:"req,1" json:"req"`
}

func NewGetInfoArgs() *GetInfoArgs {
	return &GetInfoArgs{}
}

var GetInfoArgs_Req_DEFAULT *TGetInfoReq

func (p *GetInfoArgs) GetReq() *TGetInfoReq {
	if !p.IsSetReq() {
		return GetInfoArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetInfoReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetInfoArgs(%+v)", *p)
}

type GetInfoResult struct {
	Success *TGetInfoResp `thrift:"success,0" json:"success"`
}

func NewGetInfoResult() *GetInfoResult {
	return &GetInfoResult{}
}

var GetInfoResult_Success_DEFAULT *TGetInfoResp

func (p *GetInfoResult) GetSuccess() *TGetInfoResp {
	if !p.IsSetSuccess() {
		return GetInfoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetInfoResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetInfoResult(%+v)", *p)
}

type ExecuteStatementArgs struct {
	Req *TExecuteStatementReq `thrift:"req,1" json:"req"`
}

func NewExecuteStatementArgs() *ExecuteStatementArgs {
	return &ExecuteStatementArgs{}
}

var ExecuteStatementArgs_Req_DEFAULT *TExecuteStatementReq

func (p *ExecuteStatementArgs) GetReq() *TExecuteStatementReq {
	if !p.IsSetReq() {
		return ExecuteStatementArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *ExecuteStatementArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ExecuteStatementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteStatementArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TExecuteStatementReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *ExecuteStatementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ExecuteStatement_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteStatementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *ExecuteStatementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteStatementArgs(%+v)", *p)
}

type ExecuteStatementResult struct {
	Success *TExecuteStatementResp `thrift:"success,0" json:"success"`
}

func NewExecuteStatementResult() *ExecuteStatementResult {
	return &ExecuteStatementResult{}
}

var ExecuteStatementResult_Success_DEFAULT *TExecuteStatementResp

func (p *ExecuteStatementResult) GetSuccess() *TExecuteStatementResp {
	if !p.IsSetSuccess() {
		return ExecuteStatementResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ExecuteStatementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExecuteStatementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteStatementResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TExecuteStatementResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecuteStatementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ExecuteStatement_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteStatementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteStatementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteStatementResult(%+v)", *p)
}

type GetTypeInfoArgs struct {
	Req *TGetTypeInfoReq `thrift:"req,1" json:"req"`
}

func NewGetTypeInfoArgs() *GetTypeInfoArgs {
	return &GetTypeInfoArgs{}
}

var GetTypeInfoArgs_Req_DEFAULT *TGetTypeInfoReq

func (p *GetTypeInfoArgs) GetReq() *TGetTypeInfoReq {
	if !p.IsSetReq() {
		return GetTypeInfoArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetTypeInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetTypeInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTypeInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetTypeInfoReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetTypeInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTypeInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTypeInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetTypeInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTypeInfoArgs(%+v)", *p)
}

type GetTypeInfoResult struct {
	Success *TGetTypeInfoResp `thrift:"success,0" json:"success"`
}

func NewGetTypeInfoResult() *GetTypeInfoResult {
	return &GetTypeInfoResult{}
}

var GetTypeInfoResult_Success_DEFAULT *TGetTypeInfoResp

func (p *GetTypeInfoResult) GetSuccess() *TGetTypeInfoResp {
	if !p.IsSetSuccess() {
		return GetTypeInfoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetTypeInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTypeInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTypeInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetTypeInfoResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTypeInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTypeInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTypeInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTypeInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTypeInfoResult(%+v)", *p)
}

type GetCatalogsArgs struct {
	Req *TGetCatalogsReq `thrift:"req,1" json:"req"`
}

func NewGetCatalogsArgs() *GetCatalogsArgs {
	return &GetCatalogsArgs{}
}

var GetCatalogsArgs_Req_DEFAULT *TGetCatalogsReq

func (p *GetCatalogsArgs) GetReq() *TGetCatalogsReq {
	if !p.IsSetReq() {
		return GetCatalogsArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetCatalogsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetCatalogsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCatalogsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetCatalogsReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetCatalogsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetCatalogs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCatalogsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetCatalogsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCatalogsArgs(%+v)", *p)
}

type GetCatalogsResult struct {
	Success *TGetCatalogsResp `thrift:"success,0" json:"success"`
}

func NewGetCatalogsResult() *GetCatalogsResult {
	return &GetCatalogsResult{}
}

var GetCatalogsResult_Success_DEFAULT *TGetCatalogsResp

func (p *GetCatalogsResult) GetSuccess() *TGetCatalogsResp {
	if !p.IsSetSuccess() {
		return GetCatalogsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetCatalogsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetCatalogsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCatalogsResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetCatalogsResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetCatalogsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetCatalogs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCatalogsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetCatalogsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCatalogsResult(%+v)", *p)
}

type GetSchemasArgs struct {
	Req *TGetSchemasReq `thrift:"req,1" json:"req"`
}

func NewGetSchemasArgs() *GetSchemasArgs {
	return &GetSchemasArgs{}
}

var GetSchemasArgs_Req_DEFAULT *TGetSchemasReq

func (p *GetSchemasArgs) GetReq() *TGetSchemasReq {
	if !p.IsSetReq() {
		return GetSchemasArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetSchemasArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetSchemasArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemasArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetSchemasReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetSchemasArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetSchemas_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemasArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetSchemasArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemasArgs(%+v)", *p)
}

type GetSchemasResult struct {
	Success *TGetSchemasResp `thrift:"success,0" json:"success"`
}

func NewGetSchemasResult() *GetSchemasResult {
	return &GetSchemasResult{}
}

var GetSchemasResult_Success_DEFAULT *TGetSchemasResp

func (p *GetSchemasResult) GetSuccess() *TGetSchemasResp {
	if !p.IsSetSuccess() {
		return GetSchemasResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetSchemasResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSchemasResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemasResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetSchemasResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetSchemasResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetSchemas_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemasResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSchemasResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemasResult(%+v)", *p)
}

type GetTablesArgs struct {
	Req *TGetTablesReq `thrift:"req,1" json:"req"`
}

func NewGetTablesArgs() *GetTablesArgs {
	return &GetTablesArgs{}
}

var GetTablesArgs_Req_DEFAULT *TGetTablesReq

func (p *GetTablesArgs) GetReq() *TGetTablesReq {
	if !p.IsSetReq() {
		return GetTablesArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetTablesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetTablesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTablesArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetTablesReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetTablesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTables_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTablesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetTablesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTablesArgs(%+v)", *p)
}

type GetTablesResult struct {
	Success *TGetTablesResp `thrift:"success,0" json:"success"`
}

func NewGetTablesResult() *GetTablesResult {
	return &GetTablesResult{}
}

var GetTablesResult_Success_DEFAULT *TGetTablesResp

func (p *GetTablesResult) GetSuccess() *TGetTablesResp {
	if !p.IsSetSuccess() {
		return GetTablesResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetTablesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTablesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTablesResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetTablesResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTablesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTables_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTablesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTablesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTablesResult(%+v)", *p)
}

type GetTableTypesArgs struct {
	Req *TGetTableTypesReq `thrift:"req,1" json:"req"`
}

func NewGetTableTypesArgs() *GetTableTypesArgs {
	return &GetTableTypesArgs{}
}

var GetTableTypesArgs_Req_DEFAULT *TGetTableTypesReq

func (p *GetTableTypesArgs) GetReq() *TGetTableTypesReq {
	if !p.IsSetReq() {
		return GetTableTypesArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetTableTypesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetTableTypesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableTypesArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetTableTypesReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetTableTypesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTableTypes_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableTypesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetTableTypesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableTypesArgs(%+v)", *p)
}

type GetTableTypesResult struct {
	Success *TGetTableTypesResp `thrift:"success,0" json:"success"`
}

func NewGetTableTypesResult() *GetTableTypesResult {
	return &GetTableTypesResult{}
}

var GetTableTypesResult_Success_DEFAULT *TGetTableTypesResp

func (p *GetTableTypesResult) GetSuccess() *TGetTableTypesResp {
	if !p.IsSetSuccess() {
		return GetTableTypesResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetTableTypesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableTypesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableTypesResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetTableTypesResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTableTypesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTableTypes_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableTypesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableTypesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableTypesResult(%+v)", *p)
}

type GetColumnsArgs struct {
	Req *TGetColumnsReq `thrift:"req,1" json:"req"`
}

func NewGetColumnsArgs() *GetColumnsArgs {
	return &GetColumnsArgs{}
}

var GetColumnsArgs_Req_DEFAULT *TGetColumnsReq

func (p *GetColumnsArgs) GetReq() *TGetColumnsReq {
	if !p.IsSetReq() {
		return GetColumnsArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetColumnsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetColumnsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetColumnsReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetColumnsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetColumns_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetColumnsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnsArgs(%+v)", *p)
}

type GetColumnsResult struct {
	Success *TGetColumnsResp `thrift:"success,0" json:"success"`
}

func NewGetColumnsResult() *GetColumnsResult {
	return &GetColumnsResult{}
}

var GetColumnsResult_Success_DEFAULT *TGetColumnsResp

func (p *GetColumnsResult) GetSuccess() *TGetColumnsResp {
	if !p.IsSetSuccess() {
		return GetColumnsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetColumnsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetColumnsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnsResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetColumnsResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetColumnsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetColumns_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnsResult(%+v)", *p)
}

type GetFunctionsArgs struct {
	Req *TGetFunctionsReq `thrift:"req,1" json:"req"`
}

func NewGetFunctionsArgs() *GetFunctionsArgs {
	return &GetFunctionsArgs{}
}

var GetFunctionsArgs_Req_DEFAULT *TGetFunctionsReq

func (p *GetFunctionsArgs) GetReq() *TGetFunctionsReq {
	if !p.IsSetReq() {
		return GetFunctionsArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetFunctionsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFunctionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFunctionsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetFunctionsReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetFunctionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetFunctions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFunctionsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetFunctionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFunctionsArgs(%+v)", *p)
}

type GetFunctionsResult struct {
	Success *TGetFunctionsResp `thrift:"success,0" json:"success"`
}

func NewGetFunctionsResult() *GetFunctionsResult {
	return &GetFunctionsResult{}
}

var GetFunctionsResult_Success_DEFAULT *TGetFunctionsResp

func (p *GetFunctionsResult) GetSuccess() *TGetFunctionsResp {
	if !p.IsSetSuccess() {
		return GetFunctionsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetFunctionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFunctionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFunctionsResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetFunctionsResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetFunctionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetFunctions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFunctionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetFunctionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFunctionsResult(%+v)", *p)
}

type GetOperationStatusArgs struct {
	Req *TGetOperationStatusReq `thrift:"req,1" json:"req"`
}

func NewGetOperationStatusArgs() *GetOperationStatusArgs {
	return &GetOperationStatusArgs{}
}

var GetOperationStatusArgs_Req_DEFAULT *TGetOperationStatusReq

func (p *GetOperationStatusArgs) GetReq() *TGetOperationStatusReq {
	if !p.IsSetReq() {
		return GetOperationStatusArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetOperationStatusArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetOperationStatusArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetOperationStatusArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetOperationStatusReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetOperationStatusArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetOperationStatus_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetOperationStatusArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetOperationStatusArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetOperationStatusArgs(%+v)", *p)
}

type GetOperationStatusResult struct {
	Success *TGetOperationStatusResp `thrift:"success,0" json:"success"`
}

func NewGetOperationStatusResult() *GetOperationStatusResult {
	return &GetOperationStatusResult{}
}

var GetOperationStatusResult_Success_DEFAULT *TGetOperationStatusResp

func (p *GetOperationStatusResult) GetSuccess() *TGetOperationStatusResp {
	if !p.IsSetSuccess() {
		return GetOperationStatusResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetOperationStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetOperationStatusResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetOperationStatusResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetOperationStatusResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetOperationStatusResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetOperationStatus_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetOperationStatusResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetOperationStatusResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetOperationStatusResult(%+v)", *p)
}

type CancelOperationArgs struct {
	Req *TCancelOperationReq `thrift:"req,1" json:"req"`
}

func NewCancelOperationArgs() *CancelOperationArgs {
	return &CancelOperationArgs{}
}

var CancelOperationArgs_Req_DEFAULT *TCancelOperationReq

func (p *CancelOperationArgs) GetReq() *TCancelOperationReq {
	if !p.IsSetReq() {
		return CancelOperationArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *CancelOperationArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CancelOperationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelOperationArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TCancelOperationReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *CancelOperationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CancelOperation_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelOperationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *CancelOperationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelOperationArgs(%+v)", *p)
}

type CancelOperationResult struct {
	Success *TCancelOperationResp `thrift:"success,0" json:"success"`
}

func NewCancelOperationResult() *CancelOperationResult {
	return &CancelOperationResult{}
}

var CancelOperationResult_Success_DEFAULT *TCancelOperationResp

func (p *CancelOperationResult) GetSuccess() *TCancelOperationResp {
	if !p.IsSetSuccess() {
		return CancelOperationResult_Success_DEFAULT
	}
	return p.Success
}
func (p *CancelOperationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CancelOperationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelOperationResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TCancelOperationResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *CancelOperationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CancelOperation_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelOperationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CancelOperationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelOperationResult(%+v)", *p)
}

type CloseOperationArgs struct {
	Req *TCloseOperationReq `thrift:"req,1" json:"req"`
}

func NewCloseOperationArgs() *CloseOperationArgs {
	return &CloseOperationArgs{}
}

var CloseOperationArgs_Req_DEFAULT *TCloseOperationReq

func (p *CloseOperationArgs) GetReq() *TCloseOperationReq {
	if !p.IsSetReq() {
		return CloseOperationArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *CloseOperationArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CloseOperationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseOperationArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TCloseOperationReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *CloseOperationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CloseOperation_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseOperationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *CloseOperationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseOperationArgs(%+v)", *p)
}

type CloseOperationResult struct {
	Success *TCloseOperationResp `thrift:"success,0" json:"success"`
}

func NewCloseOperationResult() *CloseOperationResult {
	return &CloseOperationResult{}
}

var CloseOperationResult_Success_DEFAULT *TCloseOperationResp

func (p *CloseOperationResult) GetSuccess() *TCloseOperationResp {
	if !p.IsSetSuccess() {
		return CloseOperationResult_Success_DEFAULT
	}
	return p.Success
}
func (p *CloseOperationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CloseOperationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseOperationResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TCloseOperationResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *CloseOperationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CloseOperation_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseOperationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CloseOperationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseOperationResult(%+v)", *p)
}

type GetResultSetMetadataArgs struct {
	Req *TGetResultSetMetadataReq `thrift:"req,1" json:"req"`
}

func NewGetResultSetMetadataArgs() *GetResultSetMetadataArgs {
	return &GetResultSetMetadataArgs{}
}

var GetResultSetMetadataArgs_Req_DEFAULT *TGetResultSetMetadataReq

func (p *GetResultSetMetadataArgs) GetReq() *TGetResultSetMetadataReq {
	if !p.IsSetReq() {
		return GetResultSetMetadataArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *GetResultSetMetadataArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetResultSetMetadataArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResultSetMetadataArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TGetResultSetMetadataReq{}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *GetResultSetMetadataArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetResultSetMetadata_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResultSetMetadataArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *GetResultSetMetadataArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResultSetMetadataArgs(%+v)", *p)
}

type GetResultSetMetadataResult struct {
	Success *TGetResultSetMetadataResp `thrift:"success,0" json:"success"`
}

func NewGetResultSetMetadataResult() *GetResultSetMetadataResult {
	return &GetResultSetMetadataResult{}
}

var GetResultSetMetadataResult_Success_DEFAULT *TGetResultSetMetadataResp

func (p *GetResultSetMetadataResult) GetSuccess() *TGetResultSetMetadataResp {
	if !p.IsSetSuccess() {
		return GetResultSetMetadataResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetResultSetMetadataResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetResultSetMetadataResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResultSetMetadataResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TGetResultSetMetadataResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResultSetMetadataResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetResultSetMetadata_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResultSetMetadataResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResultSetMetadataResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResultSetMetadataResult(%+v)", *p)
}

type FetchResultsArgs struct {
	Req *TFetchResultsReq `thrift:"req,1" json:"req"`
}

func NewFetchResultsArgs() *FetchResultsArgs {
	return &FetchResultsArgs{}
}

var FetchResultsArgs_Req_DEFAULT *TFetchResultsReq

func (p *FetchResultsArgs) GetReq() *TFetchResultsReq {
	if !p.IsSetReq() {
		return FetchResultsArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *FetchResultsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FetchResultsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FetchResultsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &TFetchResultsReq{
		Orientation: 0,
	}
	if err := p.Req.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Req, err)
	}
	return nil
}

func (p *FetchResultsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("FetchResults_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FetchResultsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:req: %s", p, err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Req, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:req: %s", p, err)
	}
	return err
}

func (p *FetchResultsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchResultsArgs(%+v)", *p)
}

type FetchResultsResult struct {
	Success *TFetchResultsResp `thrift:"success,0" json:"success"`
}

func NewFetchResultsResult() *FetchResultsResult {
	return &FetchResultsResult{}
}

var FetchResultsResult_Success_DEFAULT *TFetchResultsResp

func (p *FetchResultsResult) GetSuccess() *TFetchResultsResp {
	if !p.IsSetSuccess() {
		return FetchResultsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *FetchResultsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FetchResultsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FetchResultsResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TFetchResultsResp{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *FetchResultsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("FetchResults_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FetchResultsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FetchResultsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchResultsResult(%+v)", *p)
}
